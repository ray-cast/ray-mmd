#if SUN_SHADOW_QUALITY == 1
#	define SHADOW_MAP_SIZE 1024
#elif SUN_SHADOW_QUALITY == 2
#	define SHADOW_MAP_SIZE 2048
#elif SUN_SHADOW_QUALITY == 3
#	define SHADOW_MAP_SIZE 4096
#elif SUN_SHADOW_QUALITY == 4
#	define SHADOW_MAP_SIZE 8192
#elif SUN_SHADOW_QUALITY == 5
#	define SHADOW_MAP_SIZE 16384
#endif

texture2D DepthBuffer : RENDERDEPTHSTENCILTARGET<
	float2 ViewportRatio = {1.0,1.0};
	string Format = "D24S8";
>;
#if SSSS_QUALITY
texture2D DepthBuffer2 : RENDERDEPTHSTENCILTARGET<
	float2 ViewportRatio = {1.0,1.0};
	string Format = "D24S8";
>;
#endif
texture2D ScnMap : RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0,1.0};
	string Format = "A16B16G16R16F";
>;
sampler ScnSamp = sampler_state {
	texture = <ScnMap>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
#if FOG_ENABLE
texture FogMap: OFFSCREENRENDERTARGET<
	string Description = "Multi volumetirc fog map for ray";
	float2 ViewportRatio = {1.0, 1.0};
	string Format = "A16B16G16R16F";
	float4 ClearColor = { 0, 0, 0, 0 };
	float ClearDepth = 1.0;
	string DefaultEffect =
		"GroundFog*.*= ./Fog/GroundFog/ground_fog.fx;"
		"AtmosphericFog*.*= ./Fog/AtmosphericFog/atmospheric_fog.fx;"
		"VolumetricCube.pmx =./Fog/VolumetricCube/volumetric_cube.fx;"
		"VolumetricSphere.pmx =./Fog/VolumetricSphere/volumetric_sphere.fx;"
		"* = hide;";
>;
sampler FogMapSamp = sampler_state {
	texture = <FogMap>;
	MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
#endif
texture LightMap: OFFSCREENRENDERTARGET<
	string Description = "Multi light source map for ray";
	float2 ViewportRatio = {1.0, 1.0};
	string Format = "A16B16G16R16F";
	float4 ClearColor = { 0, 0, 0, 0 };
	float ClearDepth = 1.0;
	string DefaultEffect =
		"DirectionalLight.pmx =./Lighting/DirectionalLight/Default/directional_lighting.fx;"
		"PointLight.pmx =./Lighting/PointLight/Default/point_lighting.fx;"
		"PointLightIES.pmx =./Lighting/PointLightIES/Default/IES_lighting.fx;"
		"SpotLight.pmx =./Lighting/SpotLight/Default/spot_lighting.fx;"
		"SpotLightIES.pmx =./Lighting/SpotLightIES/Default/IES_lighting.fx;"
		"SphereLight.pmx =./Lighting/SphereLight/Default/sphere_lighting.fx;"
		"TubeLight.pmx =./Lighting/TubeLight/Default/tube_lighting.fx;"
		"LED.pmx =./Lighting/RectangleLight/Default LED/rectangle_lighting.fx;"
		"RectangleLight.pmx =./Lighting/RectangleLight/Default/rectangle_lighting.fx;"
		"* = hide;";
>;
shared texture LightSpecMap : RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0,1.0};
	string Format = "A16B16G16R16F";
>;
shared texture LightAlphaMap : RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0,1.0};
	string Format = "A16B16G16R16F";
>;
sampler LightSpecMapSamp = sampler_state {
	texture = <LightSpecMap>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
sampler LightMapSamp = sampler_state {
	texture = <LightMap>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
sampler LightAlphaMapSamp = sampler_state {
	texture = <LightAlphaMap>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
#if IBL_QUALITY
texture EnvLightMap: OFFSCREENRENDERTARGET<
	string Description = "Image-based-lighting map for ray";
	float2 ViewportRatio = {1.0, 1.0};
	string Format = "A16B16G16R16F";
	float4 ClearColor = { 0, MIDPOINT_8_BIT, 0, MIDPOINT_8_BIT };
	float ClearDepth = 1.0;
	string DefaultEffect =
		"sky*box*.* =./Skybox/skylighting_none.fx;"
		"*= hide;";
>;
shared texture EnvLightAlphaMap: RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0, 1.0};
	string Format = "A16B16G16R16F";
>;
sampler EnvLightMapSamp = sampler_state {
	texture = <EnvLightMap>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
sampler EnvLightAlphaMapSamp = sampler_state {
	texture = <EnvLightAlphaMap>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
#endif
shared texture MaterialMap: OFFSCREENRENDERTARGET<
	string Description = "Material cache map for ray";
	float2 ViewportRatio = {1.0, 1.0};
	float4 ClearColor = { 0, 0, 0, 0 };
	float ClearDepth = 1.0;
	string Format = "A8R8G8B8";
	string DefaultEffect =
		"self = hide;"
		"*fog.pmx=hide;"
		"*controller*.pmx=hide;"
		"*editor*.pmx=hide;"
		"Volumetric*.pmx=hide;"
		"sky*box*.* = ./materials/material_skybox.fx;"
		"LED*.pmx =./materials/Video/material_screen_led.fx;"
		"*Light*.pmx =./materials/Emissive/material_lighting.fx;"
		"*.pmd = ./materials/material_2.0.fx;"
		"*.pmx = ./materials/material_2.0.fx;"
		"*.x = hide;"
		"* = hide;";
>;
#if SSDO_QUALITY
texture SSAOVisibility : OFFSCREENRENDERTARGET<
	string Description = "SSAO visibility for ray";
	float2 ViewportRatio = {1.0, 1.0};
	string Format = "A8";
	float4 ClearColor = { 1, 1, 1, 1 };
	float ClearDepth = 1.0;
	string DefaultEffect =
		"self = hide;"
		"*fog.pmx=hide;"
		"*controller*.pmx=hide;"
		"*editor*.pmx=hide;"
		"Volumetric*.pmx=hide;"
		"*.*=shadow/SSAO visibility 1.0.fx;";
>;
sampler SSAOVisibilitySamp = sampler_state {
	texture = <SSAOVisibility>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
#endif
#if SUN_LIGHT_ENABLE && SUN_SHADOW_QUALITY
texture PSSM1 : OFFSCREENRENDERTARGET<
	string Description = "Cascade shadow map for ray";
	int2 Dimensions = { SHADOW_MAP_SIZE / 4, SHADOW_MAP_SIZE / 4 };
	string Format = "R32F";
	float4 ClearColor = { 0, 0, 0, 0 };
	float ClearDepth = 1.0;
	string DefaultEffect =
		"self = hide;"
		"*fog.pmx=hide;"
		"*controller*.pmx=hide;"
		"*editor*.pmx=hide;"
		"Volumetric*.pmx=hide;"
		"*.pmx=shadow/PSSM1.fx;"
		"*.pmd=shadow/PSSM1.fx;"
		"*.x=hide;";
>;
texture PSSM2 : OFFSCREENRENDERTARGET<
	string Description = "Cascade shadow map for ray";
	int2 Dimensions = { SHADOW_MAP_SIZE / 4, SHADOW_MAP_SIZE / 4 };
	string Format = "R32F";
	float4 ClearColor = { 0, 0, 0, 0 };
	float ClearDepth = 1.0;
	string DefaultEffect =
		"self = hide;"
		"*fog.pmx=hide;"
		"*controller*.pmx=hide;"
		"*editor*.pmx=hide;"
		"Volumetric*.pmx=hide;"
		"*.pmx=shadow/PSSM2.fx;"
		"*.pmd=shadow/PSSM2.fx;"
		"*.x=hide;";
>;
texture PSSM3 : OFFSCREENRENDERTARGET<
	string Description = "Cascade shadow map for ray";
	int2 Dimensions = { SHADOW_MAP_SIZE / 4, SHADOW_MAP_SIZE / 4 };
	string Format = "R16F";
	float4 ClearColor = { 0, 0, 0, 0 };
	float ClearDepth = 1.0;
	string DefaultEffect =
		"self = hide;"
		"*fog.pmx=hide;"
		"*controller*.pmx=hide;"
		"*editor*.pmx=hide;"
		"Volumetric*.pmx=hide;"
		"*.pmx=shadow/PSSM3.fx;"
		"*.pmd=shadow/PSSM3.fx;"
		"*.x=hide;";
>;
texture PSSM4 : OFFSCREENRENDERTARGET<
	string Description = "Cascade shadow map for ray";
	int2 Dimensions = { SHADOW_MAP_SIZE / 4, SHADOW_MAP_SIZE / 4 };
	string Format = "R16F";
	float4 ClearColor = { 0, 0, 0, 0 };
	float ClearDepth = 1.0;
	string DefaultEffect =
		"self = hide;"
		"*fog.pmx=hide;"
		"*controller*.pmx=hide;"
		"*editor*.pmx=hide;"
		"Volumetric*.pmx=hide;"
		"*.pmx=shadow/PSSM4.fx;"
		"*.pmd=shadow/PSSM4.fx;"
		"*.x=hide;";
>;
sampler PSSM1Samp = sampler_state {
	texture = <PSSM1>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = BORDER; AddressV = BORDER; BorderColor = 0.0;
};
sampler PSSM2Samp = sampler_state {
	texture = <PSSM2>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = BORDER; AddressV = BORDER; BorderColor = 0.0;
};
sampler PSSM3Samp = sampler_state {
	texture = <PSSM3>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = BORDER; AddressV = BORDER; BorderColor = 0.0;
};
sampler PSSM4Samp = sampler_state {
	texture = <PSSM4>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = BORDER; AddressV = BORDER; BorderColor = 0.0;
};
shared texture PSSM : RENDERCOLORTARGET<
	int2 Dimensions = { SHADOW_MAP_SIZE, SHADOW_MAP_SIZE };
	string Format = "R32F";
>;
sampler PSSMsamp = sampler_state {
	texture = <PSSM>;
	MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
shared texture2D ShadowmapMap : RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0, 1.0};
	string Format = "L8";
>;
texture2D ShadowmapMapTemp : RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0, 1.0};
	string Format = "L8";
>;
sampler ShadowMapSamp = sampler_state {
	texture = <ShadowmapMap>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
sampler ShadowMapSampTemp = sampler_state {
	texture = <ShadowmapMapTemp>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
#endif
shared texture Gbuffer2RT: RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0, 1.0};
	string Format = "A8R8G8B8";
>;
shared texture Gbuffer3RT: RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0, 1.0};
	string Format = "A8R8G8B8";
>;
shared texture Gbuffer4RT: RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0, 1.0};
	string Format = "A16B16G16R16F";
>;
shared texture Gbuffer5RT: RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0, 1.0};
	string Format = "A8R8G8B8";
>;
shared texture Gbuffer6RT: RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0, 1.0};
	string Format = "A8R8G8B8";
>;
shared texture Gbuffer7RT: RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0, 1.0};
	string Format = "A8R8G8B8";
>;
shared texture Gbuffer8RT: RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0, 1.0};
	string Format = "A16B16G16R16F";
>;
sampler Gbuffer1Map = sampler_state {
	texture = <MaterialMap>;
	MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
sampler Gbuffer2Map = sampler_state {
	texture = <Gbuffer2RT>;
	MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
sampler Gbuffer3Map = sampler_state {
	texture = <Gbuffer3RT>;
	MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
sampler Gbuffer4Map = sampler_state {
	texture = <Gbuffer4RT>;
	MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
sampler Gbuffer5Map = sampler_state {
	texture = <Gbuffer5RT>;
	MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
sampler Gbuffer6Map = sampler_state {
	texture = <Gbuffer6RT>;
	MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
sampler Gbuffer7Map = sampler_state {
	texture = <Gbuffer7RT>;
	MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
sampler Gbuffer8Map = sampler_state {
	texture = <Gbuffer8RT>;
	MinFilter = NONE; MagFilter = NONE; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
texture ShadingMap : RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0, 1.0};
	string Format = "A16B16G16R16F";
>;
texture ShadingMapTemp : RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0, 1.0};
	string Format = "A16B16G16R16F";
>;
texture ShadingMapTempSpecular : RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0, 1.0};
	string Format = "A16B16G16R16F";
>;
sampler ShadingMapSamp = sampler_state {
	texture = <ShadingMap>;
	MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
sampler ShadingMapPointSamp = sampler_state {
	texture = <ShadingMap>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
sampler ShadingMapTempSamp = sampler_state {
	texture = <ShadingMapTemp>;
	MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
sampler ShadingMapTempPointSamp = sampler_state {
	texture = <ShadingMapTemp>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
sampler ShadingMapTempSpecularSamp = sampler_state {
	texture = <ShadingMapTempSpecular>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = CLAMP; AddressV = CLAMP;
};
#if SSDO_QUALITY > 0 && (IBL_QUALITY || SUN_LIGHT_ENABLE)
shared texture SSDOMap : RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0, 1.0};
	bool AntiAlias = false;
	string Format = "A8R8G8B8";
>;
texture SSDOMapTemp : RENDERCOLORTARGET<
	float2 ViewportRatio = {1.0, 1.0};
	bool AntiAlias = false;
	string Format = "A8R8G8B8";
>;
sampler SSDOMapSamp = sampler_state {
	texture = <SSDOMap>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = CLAMP;  AddressV = CLAMP;
};
sampler SSDOMapSampTemp = sampler_state {
	texture = <SSDOMapTemp>;
	MinFilter = POINT; MagFilter = POINT; MipFilter = NONE;
	AddressU = CLAMP;  AddressV = CLAMP;
};
#endif